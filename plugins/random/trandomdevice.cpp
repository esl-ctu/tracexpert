#include "trandomdevice.h"

TRandomDevice::TRandomDevice(QString & name, QString & info): m_name(name), m_info(info), m_returnType(TConfigParam::TType::TUShort), m_returnTypeSize(0), m_preInitParamsValid(true), m_initialized(false) {
    m_preInitParams = TConfigParam(m_name + " pre-init configuration", "", TConfigParam::TType::TDummy, "");
    _createPreInitParams();
    _setDistribution("uniform_int_distribution", m_returnType, "0", "1");
}

void TRandomDevice::_createPreInitParams() {

    TConfigParam distrParam = TConfigParam("Random number distribution", "uniform_int_distribution", TConfigParam::TType::TEnum, "Which random number distribution the generator should use (see C++ RandomNumberDistribution)", false);
    distrParam.addEnumValue("uniform_int_distribution");
    distrParam.addEnumValue("binomial_distribution");
    distrParam.addEnumValue("geometric_distribution");
    distrParam.addEnumValue("poisson_distribution");
    // would behard to implement as it takex complex parameters
    // distrParam.addEnumValue("discrete_distribution");
    m_preInitParams.addSubParam(distrParam);

    TConfigParam rtypeParam = TConfigParam("Result data type", "bit-by-bit mode", TConfigParam::TType::TEnum, "The result data type generated by the generator.", false);
    // not supported by c++ std::xxx_distribution classes
    // rtypeParam.addEnumValue("qint8");
    // rtypeParam.addEnumValue("quint8");
    rtypeParam.addEnumValue("int16");
    rtypeParam.addEnumValue("uint16");
    rtypeParam.addEnumValue("int32");
    rtypeParam.addEnumValue("uint32");
    rtypeParam.addEnumValue("int64");
    rtypeParam.addEnumValue("uint64");
    rtypeParam.addEnumValue("bit-by-bit mode");
    m_preInitParams.addSubParam(rtypeParam);

    TConfigParam seedParam = TConfigParam("Seed", 0, TConfigParam::TType::TULongLong, "Random seed to initialize generator (use 0 to init with time)", false);
    m_preInitParams.addSubParam(seedParam);
}

bool TRandomDevice::_validatePreInitParamsStructure(TConfigParam & params) {

    // Only checks the structure of parameters. Values are validated later during init. Enum values are checked during their setting by the TConfigParam.

    bool iok = false;

    params.getSubParamByName("Random number distribution", &iok);
    if(!iok) return false;

    params.getSubParamByName("Result data type", &iok);
    if(!iok) return false;

    params.getSubParamByName("Seed", &iok);
    if(!iok) return false;

    return true;

}

TRandomDevice::~TRandomDevice() {
    // Nothing to do.
}

QString TRandomDevice::getIODeviceName() const {
    return m_name;
}

QString TRandomDevice::getIODeviceInfo() const {
    return m_info;
}

TConfigParam TRandomDevice::getPreInitParams() const {
    return m_preInitParams;
}

TConfigParam TRandomDevice::setPreInitParams(TConfigParam params) {

    if(m_initialized){
        params.setState(TConfigParam::TState::TError, "Cannot change pre-init parameters on an initialized device.");
        return params;
    }

    if(!_validatePreInitParamsStructure(params)){
        params.setState(TConfigParam::TState::TError, "Wrong structure of the pre-init params for RandomDevice");
        return params;
    }

    bool iok = true;

    m_preInitParams = params;
    m_preInitParams.resetState();

    m_returnType = TConfigParam::TType::TDummy;
    QString maxParameterTypeValue = "0";

    // Set Result data type
    QString rtypeParam = m_preInitParams.getSubParamByName("Result data type")->getValue();
    m_preInitParams.getSubParamByName("Result data type")->resetState();

    if(rtypeParam == "int16") {

        m_returnTypeSize = 2;
        m_returnType = TConfigParam::TType::TShort;
        maxParameterTypeValue = QString::number(std::numeric_limits<short>::max());

    } else if(rtypeParam == "uint16") {

        m_returnTypeSize = 2;
        m_returnType = TConfigParam::TType::TUShort;
        maxParameterTypeValue = QString::number(std::numeric_limits<unsigned short>::max());

    } else if(rtypeParam == "int32") {

        m_returnTypeSize = 4;
        m_returnType = TConfigParam::TType::TInt;
        maxParameterTypeValue = QString::number(std::numeric_limits<int>::max());

    } else if(rtypeParam == "uint32") {

        m_returnTypeSize = 4;
        m_returnType = TConfigParam::TType::TUInt;
        maxParameterTypeValue = QString::number(std::numeric_limits<unsigned int>::max());

    } else if(rtypeParam == "int64") {

        m_returnTypeSize = 8;
        m_returnType = TConfigParam::TType::TLongLong;
        maxParameterTypeValue = QString::number(std::numeric_limits<long long>::max());

    } else if(rtypeParam == "uint64") {

        m_returnTypeSize = 8;
        m_returnType = TConfigParam::TType::TULongLong;
        maxParameterTypeValue = QString::number(std::numeric_limits<unsigned long long>::max());

    } else if(rtypeParam == "bit-by-bit") {

        m_returnTypeSize = 0;

    } else {

        iok = false;
        m_preInitParams.getSubParamByName("Result data type")->setState(TConfigParam::TState::TError, "Invalid enum value for Result data type.");

    }


    TConfigParam postInitParams = TConfigParam(m_name + " post-init configuration", "", TConfigParam::TType::TDummy, "");

    // Set Random number distribution
    QString distrParam = m_preInitParams.getSubParamByName("Random number distribution")->getValue();
    m_preInitParams.getSubParamByName("Random number distribution")->resetState();

    if(m_returnTypeSize == 0) {

        _setDistribution("uniform_int_distribution", TConfigParam::TType::TUShort, "0", "1");

        m_preInitParams.getSubParamByName("Random number distribution")->setState(TConfigParam::TState::TInfo, "Ignoring this parameter as bit-by-bit mode was set.");

    } else if(distrParam == "uniform_int_distribution") {

        _setDistribution(distrParam, m_returnType, "0", maxParameterTypeValue);

        postInitParams.addSubParam(TConfigParam("Minimum value (a)", "0", m_returnType, "Minumum generated value."));
        postInitParams.addSubParam(TConfigParam("Maximum value (b)", maxParameterTypeValue, m_returnType, "Maximum generated value."));

    } else if(distrParam == "binomial_distribution") {

        _setDistribution(distrParam, m_returnType, "0.5");

        postInitParams.addSubParam(TConfigParam("Number of trials (t)", maxParameterTypeValue, m_returnType, "Number of trials."));
        postInitParams.addSubParam(TConfigParam("Probability of trial generating true (p)", "0.5", TConfigParam::TType::TReal, "Probability of trial generating true."));

    } else if(distrParam == "geometric_distribution") {

        _setDistribution(distrParam, m_returnType, "0.5");

        postInitParams.addSubParam(TConfigParam("Probability of trial generating true (p)", "0.5", TConfigParam::TType::TReal, "Probability of trial generating true."));

    } else if(distrParam == "poisson_distribution") {

        _setDistribution(distrParam, m_returnType, "100");

        postInitParams.addSubParam(TConfigParam("Mean of the distribution (Mu)", "100", TConfigParam::TType::TReal, "The mean of the distribution."));

    } else {

        iok = false;
        m_preInitParams.getSubParamByName("Random number distribution")->setState(TConfigParam::TState::TError, "Invalid enum value for Random number distribution.");

    }

    if(iok) {
        m_postInitParams = postInitParams;
    }

    m_preInitParamsValid = iok;

    return m_preInitParams;
}

bool TRandomDevice::_setDistribution(QString distributionName, TConfigParam::TType dataType, QString p1, QString p2) {

    if(distributionName == "uniform_int_distribution") {

        switch(dataType) {
            case TConfigParam::TType::TShort:       _setDistributionFunc(std::uniform_int_distribution<short>               (p1.toShort(),      p2.toShort()));     break;
            case TConfigParam::TType::TUShort:      _setDistributionFunc(std::uniform_int_distribution<unsigned short>      (p1.toUShort(),     p2.toUShort()));    break;
            case TConfigParam::TType::TInt:         _setDistributionFunc(std::uniform_int_distribution<int>                 (p1.toInt(),        p2.toInt()));       break;
            case TConfigParam::TType::TUInt:        _setDistributionFunc(std::uniform_int_distribution<unsigned int>        (p1.toUInt(),       p2.toUInt()));      break;
            case TConfigParam::TType::TLongLong:    _setDistributionFunc(std::uniform_int_distribution<long long>           (p1.toLongLong(),   p2.toLongLong()));  break;
            case TConfigParam::TType::TULongLong:   _setDistributionFunc(std::uniform_int_distribution<unsigned long long>  (p1.toULongLong(),  p2.toULongLong())); break;
            default: return false;
        }

        return true;

    } else if(distributionName == "binomial_distribution") {

        switch(dataType) {
            case TConfigParam::TType::TShort:       _setDistributionFunc(std::binomial_distribution<short>                  (p1.toShort(),      p2.toDouble()));   break;
            case TConfigParam::TType::TUShort:      _setDistributionFunc(std::binomial_distribution<unsigned short>         (p1.toUShort(),     p2.toDouble()));   break;
            case TConfigParam::TType::TInt:         _setDistributionFunc(std::binomial_distribution<int>                    (p1.toInt(),        p2.toDouble()));   break;
            case TConfigParam::TType::TUInt:        _setDistributionFunc(std::binomial_distribution<unsigned int>           (p1.toUInt(),       p2.toDouble()));   break;
            case TConfigParam::TType::TLongLong:    _setDistributionFunc(std::binomial_distribution<long long>              (p1.toLongLong(),   p2.toDouble()));   break;
            case TConfigParam::TType::TULongLong:   _setDistributionFunc(std::binomial_distribution<unsigned long long>     (p1.toULongLong(),  p2.toDouble()));   break;
            default: return false;
        }

        return true;

    } else if(distributionName == "geometric_distribution") {

        switch(dataType) {
            case TConfigParam::TType::TShort:       _setDistributionFunc(std::geometric_distribution<short>                 (p1.toDouble()));   break;
            case TConfigParam::TType::TUShort:      _setDistributionFunc(std::geometric_distribution<unsigned short>        (p1.toDouble()));   break;
            case TConfigParam::TType::TInt:         _setDistributionFunc(std::geometric_distribution<int>                   (p1.toDouble()));   break;
            case TConfigParam::TType::TUInt:        _setDistributionFunc(std::geometric_distribution<unsigned int>          (p1.toDouble()));   break;
            case TConfigParam::TType::TLongLong:    _setDistributionFunc(std::geometric_distribution<long long>             (p1.toDouble()));   break;
            case TConfigParam::TType::TULongLong:   _setDistributionFunc(std::geometric_distribution<unsigned long long>    (p1.toDouble()));   break;
            default: return false;
        }

        return true;

    } else if(distributionName == "poisson_distribution") {

        switch(dataType) {
            case TConfigParam::TType::TShort:       _setDistributionFunc(std::poisson_distribution<short>                   (p1.toDouble()));   break;
            case TConfigParam::TType::TUShort:      _setDistributionFunc(std::poisson_distribution<unsigned short>          (p1.toDouble()));   break;
            case TConfigParam::TType::TInt:         _setDistributionFunc(std::poisson_distribution<int>                     (p1.toDouble()));   break;
            case TConfigParam::TType::TUInt:        _setDistributionFunc(std::poisson_distribution<unsigned int>            (p1.toDouble()));   break;
            case TConfigParam::TType::TLongLong:    _setDistributionFunc(std::poisson_distribution<long long>               (p1.toDouble()));   break;
            case TConfigParam::TType::TULongLong:   _setDistributionFunc(std::poisson_distribution<unsigned long long>      (p1.toDouble()));   break;
            default: return false;
        }

        return true;

    }

    return false;
}

template<typename T>
void TRandomDevice::_setDistributionFunc(T distribution) {
    // As there is no common interface between std::xxx_distribution classes,
    // the distribution class instance, or more precisely its operator()
    // is stored as a std::function<>. It takes two parameters, the random engine
    // and the byte buffer, where it stores the result (generated random value)
    // of arbitrary length (previously set in this function on instantiation).

    m_distribution_func = [distribution](RANDOM_GENERATOR_TYPE& engine, uint8_t * buffer) mutable {
        auto randVal = distribution(engine);
        memcpy(buffer, &randVal, sizeof randVal);
    };
}

void TRandomDevice::init(bool *ok) {

    if(m_initialized) {
        qWarning("TRandomDevice was already initialized when init was called!");

        if(ok != nullptr) *ok = false;
        return;
    }

    // when recursive checking of config parameters is ready,
    // check if preInitParams is ok here!
    // for now check m_preInitParamsValid...

    if(!m_preInitParamsValid) {
        qWarning("Cannot initialize TRandomDevice with invalid pre-init parameters!");

        if(ok != nullptr) *ok = false;
        return;
    }

    // std::random_device could also be used for seed...

    // no need to check validity - it should already have been validated when setting value
    quint64 seed = m_preInitParams.getSubParamByName("Seed")->getValue().toULongLong();
    m_engine.seed(seed == 0 ? time(0) : seed);


    if(ok != nullptr) *ok = true;

    m_initialized = true;
}

void TRandomDevice::deInit(bool *ok) {

    if(ok != nullptr) *ok = true;

    m_initialized = false;

}

TConfigParam TRandomDevice::getPostInitParams() const {
    return m_postInitParams;
}

TConfigParam TRandomDevice::setPostInitParams(TConfigParam params) {

    if(!m_initialized) {
        params.setState(TConfigParam::TState::TError, "Cannot set post-init parameters on an uninitialized device.");
        return params;
    }

    if(!_validatePostInitParamsStructure(params)) {
        params.setState(TConfigParam::TState::TError, "Wrong structure of the post-init params for TRandomDevice.");
        return params;
    }

    m_postInitParams = params;


    QString distrParam = m_preInitParams.getSubParamByName("Random number distribution")->getValue();

    if(m_returnTypeSize == 0) {

        qWarning("Ignoring post-init parameters as bit-by-bit mode was set.");
        return m_postInitParams;

    } else if(distrParam == "uniform_int_distribution") {

        _setDistribution(distrParam, m_returnType, m_postInitParams.getSubParamByName("Minimum value (a)")->getValue(), m_postInitParams.getSubParamByName("Maximum value (b)")->getValue());

    } else if(distrParam == "binomial_distribution") {

        _setDistribution(distrParam, m_returnType, m_postInitParams.getSubParamByName("Number of trials (t)")->getValue(), m_postInitParams.getSubParamByName("Probability of trial generating true (p)")->getValue());

    } else if(distrParam == "geometric_distribution") {

        _setDistribution(distrParam, m_returnType, m_postInitParams.getSubParamByName("Probability of trial generating true (p)")->getValue());

    } else if(distrParam == "poisson_distribution") {

        _setDistribution(distrParam, m_returnType, m_postInitParams.getSubParamByName("Mean of the distribution (Mu)")->getValue());

    }

    return m_postInitParams;

}

bool TRandomDevice::_validatePostInitParamsStructure(TConfigParam & params) {

    // Only checks the structure of parameters. Values are validated later during init. Enum values are checked during their setting by the TConfigParam.

    bool iok = false;

    QString distrParam = m_preInitParams.getSubParamByName("Random number distribution")->getValue();

    if(m_returnTypeSize == 0) {

        return true;

    } else if(distrParam == "uniform_int_distribution") {

        params.getSubParamByName("Minimum value (a)", &iok);
        if(!iok) return false;

        params.getSubParamByName("Maximum value (b)", &iok);
        if(!iok) return false;

    } else if(distrParam == "binomial_distribution") {

        params.getSubParamByName("Number of trials (t)", &iok);
        if(!iok) return false;

        params.getSubParamByName("Probability of trial generating true (p)", &iok);
        if(!iok) return false;

    } else if(distrParam == "geometric_distribution") {

        params.getSubParamByName("Probability of trial generating true (p)", &iok);
        if(!iok) return false;

    } else if(distrParam == "poisson_distribution") {

        params.getSubParamByName("Mean of the distribution (Mu)", &iok);
        if(!iok) return false;

    }

    return true;

}

size_t TRandomDevice::writeData(const uint8_t * buffer, size_t len) {

    qWarning("TRandomDevice is readonly!");

    return 0;

}

size_t TRandomDevice::readData(uint8_t * buffer, size_t len) {

    if(!m_initialized) {
        qWarning("TRandomDevice was not yet initialized!");
        return 0;
    }

    if(m_returnTypeSize == 0) {
        // bit-by-bit mode
        // assumes uniform distribution and short result type in <0, 1> range
        uint8_t tmpBuffer[2];

        for(size_t i = 0; i < len; i++) {
            for(int j = 0; j < 8; j++) {
                m_distribution_func(m_engine, tmpBuffer);
                buffer[i] |= (tmpBuffer[0] & 1);
                buffer[i] <<= 1;
            }
        }

    } else {

        if(len != m_returnTypeSize) {
            qWarning("Length of read is not equal to length of generated value type!");
            return 0;
        }

        m_distribution_func(m_engine, buffer);

    }

    return len;
}
